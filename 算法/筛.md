# 筛 （Sieve）

> - 筛（sieve）是一类用于生成素数（质数）或判断区间中素数的算法。常见目标是列出小于等于 N 的所有素数或判断区间  [ L,  R ]  中的素数。

## 1.埃拉托斯特尼筛（Sieve of Eratosthenes）

- 原理：从 2 开始，依次把当前质数 p 的所有倍数标记为合数。对于 p，只需从 p * p 开始标记（更小的倍数已被较小质数标记）。
- 复杂度：O(N log log N) 时间，O(N) 空间。
- 适用场景：当 N 不太大，可以在内存中建立长度 N 的数组时（例如 N ≤ 1e8 取决于内存与实现方式）。

``` C++
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    long long n;
    if (!(cin >> n)) return 0;
    if (n < 2) {
        cout << "0\n";
        return 0;
    }
    vector<char> is_prime(n + 1, true);
    is_prime[0] = is_prime[1] = false;
    long long limit = sqrt((long double)n);
    for (long long p = 2; p <= limit; ++p) {
        if (!is_prime[p]) continue;
        for (long long q = p * p; q <= n; q += p) {
            is_prime[q] = false;
        }
    }
    long long cnt = 0;
    for (long long i = 2; i <= n; ++i) {
        if (is_prime[i]) {
            cout << i << '\n';
            ++cnt;
        }
    }
    cerr << "Count = " << cnt << '\n';
    return 0;
}
```

## 2. 线性筛（Euler / Linear sieve）

- 原理：每个合数只被其最小质因子筛掉一次，确保每个数只被筛选一次。
- 复杂度：O(N) 时间，O(N) 空间。
- 优势：比埃拉托斯特尼筛更高效，时间复杂度为线性。
- 适用场景：需要高效生成素数列表，且对时间复杂度要求较高时。

```C++
#include <bits/stdc++.h>
using namespace std;

vector<int> primes;
vector<bool> is_prime;

void linear_sieve(int n) {
    is_prime.assign(n + 1, true);
    is_prime[0] = is_prime[1] = false;
    
    for (int i = 2; i <= n; ++i) {
        if (is_prime[i]) {
            primes.push_back(i);
        }
        
        for (int j = 0; j < primes.size() && i * primes[j] <= n; ++j) {
            is_prime[i * primes[j]] = false;
            if (i % primes[j] == 0) {
                // i 的最小质因子是 primes[j]
                // 所以 i * primes[j+1] 的最小质因子也是 primes[j]
                // 为避免重复筛选，此处 break
                break;
            }
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n;
    cin >> n;
    
    linear_sieve(n);
    
    cout << "素数个数: " << primes.size() << '\n';
    cout << "前20个素数: ";
    for (int i = 0; i < min(20, (int)primes.size()); ++i) {
        cout << primes[i] << " ";
    }
    cout << '\n';
    
    return 0;
}
```

## 3. 分段筛（Segmented sieve）

- 原理：将大区间分成若干小段，先用普通筛法得到 √R 以内的所有素数，然后用这些素数去筛每个小段。
- 复杂度：O(R log log R) 时间，O(√R + segment_size) 空间。
- 适用场景：当需要筛选的范围很大（如 [L, R]，其中 L 和 R 可能很大）但无法一次性分配足够内存时。
- 优势：内存占用小，可以处理很大的区间。

```C++
#include <bits/stdc++.h>
using namespace std;

// 普通筛法生成小于等于 sqrt(high) 的所有素数
vector<long long> simple_sieve(long long limit) {
    vector<bool> is_prime(limit + 1, true);
    vector<long long> primes;
    
    is_prime[0] = is_prime[1] = false;
    
    for (long long i = 2; i <= limit; ++i) {
        if (is_prime[i]) {
            primes.push_back(i);
            for (long long j = i * i; j <= limit; j += i) {
                is_prime[j] = false;
            }
        }
    }
    return primes;
}

// 分段筛：筛选区间 [low, high] 中的素数
vector<long long> segmented_sieve(long long low, long long high) {
    long long limit = sqrt(high) + 1;
    vector<long long> primes = simple_sieve(limit);
    
    long long segment_size = high - low + 1;
    vector<bool> is_prime(segment_size, true);
    
    // 处理特殊情况
    if (low == 1) {
        is_prime[0] = false; // 1 不是素数
    }
    
    // 用小素数筛选区间 [low, high]
    for (long long prime : primes) {
        // 找到第一个大于等于 low 且能被 prime 整除的数
        long long start = max(prime * prime, (low + prime - 1) / prime * prime);
        
        for (long long j = start; j <= high; j += prime) {
            is_prime[j - low] = false;
        }
    }
    
    vector<long long> result;
    for (long long i = 0; i < segment_size; ++i) {
        if (is_prime[i] && (low + i) > 1) {
            result.push_back(low + i);
        }
    }
    
    return result;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    long long low, high;
    cout << "输入区间 [low, high]: ";
    cin >> low >> high;
    
    vector<long long> primes = segmented_sieve(low, high);
    
    cout << "区间 [" << low << ", " << high << "] 中的素数个数: " << primes.size() << '\n';
    cout << "素数列表: ";
    for (long long prime : primes) {
        cout << prime << " ";
    }
    cout << '\n';
    
    return 0;
}
```

## 4. 算法比较总结

| 算法 | 时间复杂度 | 空间复杂度 | 适用场景 |
|------|------------|------------|----------|
| 埃拉托斯特尼筛 | O(N log log N) | O(N) | N 较小，内存充足 |
| 线性筛 | O(N) | O(N) | 需要高效生成素数列表 |
| 分段筛 | O(R log log R) | O(√R + segment_size) | 大区间，内存受限 |

## 5. 应用场景

### 埃拉托斯特尼筛
- 适合 N ≤ 10^7 的情况
- 实现简单，容易理解

### 线性筛
- 需要生成大量素数时
- 对时间复杂度要求严格
- 可以同时计算其他数论函数（如欧拉函数）

### 分段筛
- 查询区间 [L, R] 中的素数，其中 L, R 可能很大
- 内存受限的情况
- L 和 R 的差值不是很大（相对于 R 的大小）

## 6. 优化技巧

1. **奇数优化**：只考虑奇数，可以节省一半空间和时间
2. **轮筛**：使用 2, 3, 5 的倍数进行预筛选
3. **位操作**：使用位数组代替 bool 数组节省内存
4. **缓存友好**：分块处理以提高缓存命中率


